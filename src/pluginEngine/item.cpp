/**********************************************************************************
 *autorealm - A vectorized graphic editor to create maps, mostly for RPG games    *
 *Copyright (C) 2012 Morel BÃ©renger                                               *
 *                                                                                *
 *This file is part of autorealm.                                                 *
 *                                                                                *
 *    autorealm is free software: you can redistribute it and/or modify           *
 *    it under the terms of the GNU General Public License as published by        *
 *    the Free Software Foundation, either version 3 of the License, or           *
 *    (at your option) any later version.                                         *
 *                                                                                *
 *    autorealm is distributed in the hope that it will be useful,                *
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of              *
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
 *    GNU General Public License for more details.                                *
 *                                                                                *
 *    You should have received a copy of the GNU General Public License           *
 *    along with autorealm.  If not, see <http://www.gnu.org/licenses/>.          *
 **********************************************************************************/
#include "item.h"

#include "container.h"

#include <stdexcept>

#include <wx/menu.h>
#include <wx/frame.h>

#include "../gui/appconfig.h"

Item::Item(std::string const& cfgFileName)
:m_configFileName(cfgFileName),m_id(wxNewId()),m_callback(NULL)
{
}

void Item::readConfig(void)
{
//!\todo check the portability of this method
//!\todo think about a configuration written in a pseudo file-system. Something like Menu<=>directory and Item<=>file
	FILE *input=0;
	std::string configFileFullPath=AppConfig::buildPath(AppConfig::INFO::CONFIG)+AppConfig::buildPath(AppConfig::INFO::PLUGINS)+m_configFileName;
	input=fopen(configFileFullPath.c_str(),"r");
	if(!input)
		throw std::runtime_error("can not open the file "+configFileFullPath);//!\todo write config and retry to read configuration before leaving

	readConfig(input);

	m_toolbarItem.readFromFile(input);

	//retrieve all path entries
	MenuData entry;
	do
	{
		try
		{
			entry.readFromFile(input);
		}catch(std::runtime_error &e)
		{
			throw e;
		}
		m_path.push_back(entry);
	}while(!eofReached(input));

	if(m_path.empty())
		throw std::runtime_error("configuration file corrupted");
	fclose(input);
}

Item::~Item(void)
{
}

//void Item::registerIn(wxFrame *parent,std::map<std::string,Container>&containers)
//{
//	/**\todo move this method in MainFrame: it only use m_path, m_toolbarItem and m_id.
//	But m_path will be moved in MainFrame
//	MainFrame should generate m_id, because it is generated by wxWidgets and so augment dependencies of Item
//	m_toolbarItem can be accessed with an accessor
//	*/
//	readConfig();
//	wxMenu *lastMenu=createMenu(parent);
////TODO make this function doing something
//	std::string name=m_path.back().getName();
//
//	if(containers.find(name)==containers.end())
//		containers[name].createToolbar(name,parent);
//
//	containers[name].createItem(m_toolbarItem,m_id);
//	static_cast<MenuData>(m_toolbarItem).addTo(lastMenu, m_id);
//}

wxMenu* Item::createMenu(wxFrame *parent)const
{
	if(m_path.empty())
		throw std::runtime_error("Empty path are not allowed");

	wxMenuBar *menubar=parent->GetMenuBar();
	wxMenu *lastMenu=0;
	int id;
	std::vector<MenuData>::const_iterator it=m_path.begin();

	//retrieve the id of the first menu if existing and create it else
	id=it->findIn(menubar);
	if(MenuData::NOT_FOUND==id) // not found? Create it and get the new menu
	{
		it->addTo(menubar);
		id=it->findIn(menubar);
		if(MenuData::NOT_FOUND==id)
			throw std::runtime_error("Can not find the menu with FindMenu, but we just create it!");
	}
	lastMenu=menubar->GetMenu(id);
	if(NULL==lastMenu)
		throw std::runtime_error("FindMenu gives something but GetMenu failed!");
	lastMenu=findLastMenu(lastMenu,it);
	lastMenu=createMenuPath(lastMenu,it);

	return lastMenu;
}

wxMenu* Item::findLastMenu(wxMenu *parent,std::vector<MenuData>::const_iterator &it)const
{
	it=m_path.begin();
	++it;
	//get the iterator corresponding to the last matching menu
	for(;it!=m_path.end();++it)
		if(!it->exist(parent))
			break;
	--it;

	long id=it->findIn(parent);
	if(MenuData::NOT_FOUND!=id)
		parent=parent->FindItem(id)->GetSubMenu();
	return parent;
}

wxMenu *Item::createMenuPath(wxMenu *parent,std::vector<MenuData>::const_iterator &it)const
{
	++it;
	if(m_path.end()==it)
		return parent;

	wxMenu *newMenu=it->addTo(parent);
	return createMenuPath(newMenu,it);
}

PLUMA_PROVIDER_SOURCE(Item,1,1)
